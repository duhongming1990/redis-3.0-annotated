# 2 简单动态字符串（Simple Dynamic String，SDS）
sds.h/sdshdr 保存字符串对象的结构：
```cfml
/*
 * 保存字符串对象的结构
 */
struct sdshdr {
    
    // buf 中已占用空间的长度
    int len;

    // buf 中剩余可用空间的长度
    int free;

    // 数据空间
    char buf[];
};
```
优点：

1. 常数复杂度获取字符串长度，从C字符串的O(n)到SDS字符串的O(1)。
2. 杜绝缓冲区溢出（buffer overflow）
3. 减少修改字符串时带来的内存重新分配次数

    空间预分配：小于1MB，free = len；大于等于1MB，free+1MB。
    惰性空间释放：字符串缩短操作，用free记录起来。
4. 二进制安全
5. 兼容部分C字符串函数

# 3 链表
adlist.h/listNode 双端链表节点：
```c
/*
 * 双端链表节点
 */
typedef struct listNode {

    // 前置节点
    struct listNode *prev;

    // 后置节点
    struct listNode *next;

    // 节点的值
    void *value;

} listNode;
```
adlist.h/list 双端链表结构：
```cfml
/*
 * 双端链表结构
 */
typedef struct list {

    // 表头节点
    listNode *head;

    // 表尾节点
    listNode *tail;

    // 节点值复制函数
    void *(*dup)(void *ptr);

    // 节点值释放函数
    void (*free)(void *ptr);

    // 节点值对比函数
    int (*match)(void *ptr, void *key);

    // 链表所包含的节点数量
    unsigned long len;

} list;
```
优点：
1. 双端：获取前置节点和后置节点的时间复杂度都是O(1)
2. 无环：对链表的访问以NULL为终点
3. 带表头指针和表尾指针，复杂度为O(1)
4. 带链表长度计数器，复杂度为O(1)
5. 多态

# 4 字典
又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种保存键值对（key-value pair）的抽象数据结构。

dict.h/dict 字典:
```cfml
/*
 * 字典
 */
typedef struct dict {

    // 类型特定函数
    dictType *type;

    // 私有数据
    void *privdata;

    // 哈希表
    dictht ht[2];

    // rehash 索引
    // 当 rehash 不在进行时，值为 -1
    int rehashidx; /* rehashing not in progress if rehashidx == -1 */

    // 目前正在运行的安全迭代器的数量
    int iterators; /* number of iterators currently running */

} dict;
```

dict.h/dictht 哈希表:
```cfml
/* This is our hash table structure. Every dictionary has two of this as we
 * implement incremental rehashing, for the old to the new table. */
/*
 * 哈希表
 *
 * 每个字典都使用两个哈希表，从而实现渐进式 rehash 。
 */
typedef struct dictht {
    
    // 哈希表数组
    dictEntry **table;

    // 哈希表大小
    unsigned long size;
    
    // 哈希表大小掩码，用于计算索引值
    // 总是等于 size - 1
    unsigned long sizemask;

    // 该哈希表已有节点的数量
    unsigned long used;

} dictht;
```

dict.h/dictht 哈希表节点:
```cfml
/*
 * 哈希表节点
 */
typedef struct dictEntry {
    
    // 键
    void *key;

    // 值
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;

    // 指向下个哈希表节点，形成链表
    struct dictEntry *next;

} dictEntry;
```
总结：
1. 每个字典有两个哈希表，一个平时使用，另一个进行渐进式rehash时使用
2. Redis使用MurmurHash2算法计算哈希建的哈希值
3. 哈希表使用链地址法解决键冲突，形成单向链表，表头位置插入，复杂度O(1)

# 5 跳跃表（skiplist）
redis.h/zskiplist 跳跃表:
```cfml
/*
 * 跳跃表
 */
typedef struct zskiplist {

    // 表头节点和表尾节点
    struct zskiplistNode *header, *tail;

    // 表中节点的数量
    unsigned long length;

    // 表中层数最大的节点的层数
    int level;

} zskiplist;
```
redis.h/zskiplistNode 跳跃表节点:
```cfml

/* ZSETs use a specialized version of Skiplists */
/*
 * 跳跃表节点
 */
typedef struct zskiplistNode {

    // 成员对象
    robj *obj;

    // 分值
    double score;

    // 后退指针
    struct zskiplistNode *backward;

    // 层
    struct zskiplistLevel {

        // 前进指针
        struct zskiplistNode *forward;

        // 跨度
        unsigned int span;

    } level[];

} zskiplistNode;
```

# 6 整数集合（intset）
intset.h/intset 整数集合:
```cfml
typedef struct intset {
    
    // 编码方式
    uint32_t encoding;

    // 集合包含的元素数量
    uint32_t length;

    // 保存元素的数组
    int8_t contents[];

} intset;
```
通过encoding：INTSET_ENC_INT16、INTSET_ENC_INT32、INTSET_ENC_INT64升级的好处：
1. 提升灵活性
2. 节约内存
3. 不支持降级操作

# 7 压缩列表（ziplist）
ziplist.c:
```cfml
/* 
空白 ziplist 示例图

area        |<---- ziplist header ---->|<-- end -->|

size          4 bytes   4 bytes 2 bytes  1 byte
            +---------+--------+-------+-----------+
component   | zlbytes | zltail | zllen | zlend     |
            |         |        |       |           |
value       |  1011   |  1010  |   0   | 1111 1111 |
            +---------+--------+-------+-----------+
                                       ^
                                       |
                               ZIPLIST_ENTRY_HEAD
                                       &
address                        ZIPLIST_ENTRY_TAIL
                                       &
                               ZIPLIST_ENTRY_END

非空 ziplist 示例图

area        |<---- ziplist header ---->|<----------- entries ------------->|<-end->|

size          4 bytes  4 bytes  2 bytes    ?        ?        ?        ?     1 byte
            +---------+--------+-------+--------+--------+--------+--------+-------+
component   | zlbytes | zltail | zllen | entry1 | entry2 |  ...   | entryN | zlend |
            +---------+--------+-------+--------+--------+--------+--------+-------+
                                       ^                          ^        ^
address                                |                          |        |
                                ZIPLIST_ENTRY_HEAD                |   ZIPLIST_ENTRY_END
                                                                  |
                                                        ZIPLIST_ENTRY_TAIL
*/
```
# 8 对象
```cfml
typedef struct redisObject {

    // 类型
    /**
        TYPE key
        8.1 对象类型
        +---------------+---------------+
        |  类型常量      |对象的名称      | 
        +---------------+---------------+
        |  REDIS_STRING | 字符串对象     | 
        |  REDIS_LIST   | 列表对象       |
        |  REDIS_HASH   | 哈希对象       |
        |  REDIS_SET    | 集合对象       |
        |  REDIS_ZSET   | 有序集合对象   |
        +---------+---------------------+
    */
    unsigned type:4;

    // 编码
    /**
        OBJECT ENCODING key
        
        8.2 字符串对象
        REDIS_ENCODING_INT(int值时)
        REDIS_ENCODING_RAW（>39字节）
        REDIS_ENCODING_EMBSTR（<=39字节）
        
        8.3 列表对象
        REDIS_ENCODING_ZIPLIST（所有字符串长度<64字节；对象数量<512）
        REDIS_ENCODING_LINKEDLIST（else）
        通过list-max-ziplist-value/list-max-ziplist-entries修改
        
        8.4 哈希对象
        REDIS_ENCODING_ZIPLIST（所有字符串长度<64字节；对象数量<512）
        REDIS_ENCODING_HT（else）
        通过hash-max-ziplist-value/hash-max-ziplist-entries修改
        
        8.5 集合对象
        REDIS_ENCODING_INTSET（全部为整数；对象数量<512）
        REDIS_ENCODING_HT（else）
        通过set-max-intset-entries修改
        
        8.6 有序集合对象
        REDIS_ENCODING_ZIPLIST（所有字符串长度<64字节；对象数量<128）
        REDIS_ENCODING_HT（else）
        通过zset-max-ziplist-value/zset-max-ziplist-entries修改
    */
    unsigned encoding:4;

    // 对象最后一次被访问的时间
    /**
        OBJECT IDLETIME key
        
        8.10 对象的空转时长
        
        键出于活跃状态，空转时长为0
        
        # maxmemory <bytes>
        
        # MAXMEMORY POLICY: how Redis will select what to remove when maxmemory
        # is reached. You can select among five behaviors:
        #
        # volatile-lru -> remove the key with an expire set using an LRU algorithm
        # allkeys-lru -> remove any key according to the LRU algorithm
        # volatile-random -> remove a random key with an expire set
        # allkeys-random -> remove a random key, any key
        # volatile-ttl -> remove the key with the nearest expire time (minor TTL)
        # noeviction -> don't expire at all, just return an error on write operations
        # maxmemory-policy noeviction
        
    */
    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */

    // 引用计数
    /**
        8.8 内存回收
        引用计数（Reference counting）技术实现内存回收机制
    */
    int refcount;

    // 指向实际值的指针
    void *ptr;

} robj;
```
## 8.9 对象共享
通过修改redis.h/REDIS_SHARED_INTEGERS
```cfml
#define REDIS_SHARED_INTEGERS 10000(0-9999)
```


# 9 数据库

## 9.1 服务器中的数据库
redis.h/redisServer
```cfml
struct redisServer {
    // 数据库
    redisDb *db;
    int dbnum; /* Total number of configured DBs */
}
```
可以在配置文件中配置：databases 16

## 9.2 切换数据库
redis.h/redisClient
```cfml
typedef struct redisClient {
    // 当前正在使用的数据库
    redisDb *db;
    // 当前正在使用的数据库的 id （号码）
    int dictid;
}
```
命令：
    
    SELECT <dbid>

## 9.3 数据库键空间(key space)
redis.h/redisDb
```cfml
typedef struct redisDb {
    // 数据库键空间，保存着数据库中的所有键值对
    dict *dict;  /* The keyspace for this DB */
```
## 9.4 设置键的生存时间（time to live，TTL）或过期时间

### 9.4.1 设置过期时间
    EXPIRE key ttl
    PEXPIRE key ttl
    EXPIREAT key timestamp
    PEXPIREAT key timestamp（最终执行的命令）
    
### 9.4.2 保存过期时间
redis.h/redisDb
```cfml
typedef struct redisDb {
    // 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳
    dict *expires; 
}
```

### 9.4.3 移除过期时间
    PERSIST key

### 9.4.4 计算并返回剩余生存时间
    TTL key
    PTTL key
    
### 9.4.5 过期键的判定
1. 检查给定键是否在过期字典中：存在，则获取。
2. 检查当前的UNIX时间戳与键的过期时间。

## 9.5 过期键删除策略
    定时删除：不现实
    惰性删除：expireIfNeeded函数实现
    定期删除：activeExpireCycle函数实现

## 9.6 AOF、RDB和复制功能对过期键的处理
    执行SAVE、BGSAVE生成RDB文件和执行BGREWRITEAOF生成的AOF不会包含过期键
    主服务器删除一个过期键之后，会向所有从服务器发送一条DEL命令，从服务器即使发现过期键也不会自作主张地删除它。
    
# 10 RDB持久化

## 10.1 RDB文件的创建于载入
    SAVE阻塞Redis服务器进程
    BGSAVE会派生出一个子进程，Redis父进程继续处理命令请求
    AOF开启的话，优先使用
    
## 10.2 自动间隔性保存

### 10.2.1 设置保存条件
```
#   In the example below the behaviour will be to save:
#   after 900 sec (15 min) if at least 1 key changed
#   after 300 sec (5 min) if at least 10 keys changed
#   after 60 sec if at least 10000 keys changed
save 900 1
save 300 10
save 60 10000
```

redis.h/redisServer
```cfml

struct redisServer {
    struct saveparam *saveparams;   /* Save points array for RDB */
    int saveparamslen;              /* Number of saving points */
}

// 服务器的保存条件（BGSAVE 自动执行的条件）
struct saveparam {

    // 多少秒之内
    time_t seconds;

    // 发生多少次修改
    int changes;

};

```

### 10.2.2 dirty计数器和lastsave属性
```cfml
struct redisServer {
    // 自从上次 SAVE 执行以来，数据库被修改的次数
    long long dirty;                /* Changes to DB from the last save */

    // BGSAVE 执行前的数据库被修改次数
    long long dirty_before_bgsave;  /* Used to restore dirty on failed BGSAVE */
}
```

### 10.2.3 检查保存条件是否满足

## 10.3 RDB文件结构
    REDIS | db_version | databasees | EOF | check_sums
## 10.4 分析RDB文件
    redis-check-dump 或者 od -cx dump.rdb

# 11 AOF（Append Only File）持久化

# 12 事件

