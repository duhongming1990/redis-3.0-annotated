# 2 简单动态字符串（Simple Dynamic String，SDS）
sds.h/sdshdr 保存字符串对象的结构：
```cfml
/*
 * 保存字符串对象的结构
 */
struct sdshdr {
    
    // buf 中已占用空间的长度
    int len;

    // buf 中剩余可用空间的长度
    int free;

    // 数据空间
    char buf[];
};
```
优点：

1. 常数复杂度获取字符串长度，从C字符串的O(n)到SDS字符串的O(1)。
2. 杜绝缓冲区溢出（buffer overflow）
3. 减少修改字符串时带来的内存重新分配次数

    空间预分配：小于1MB，free = len；大于等于1MB，free+1MB。
    惰性空间释放：字符串缩短操作，用free记录起来。
4. 二进制安全
5. 兼容部分C字符串函数

#3 链表
adlist.h/listNode 双端链表节点：
```c
/*
 * 双端链表节点
 */
typedef struct listNode {

    // 前置节点
    struct listNode *prev;

    // 后置节点
    struct listNode *next;

    // 节点的值
    void *value;

} listNode;
```
adlist.h/list 双端链表结构：
```cfml
/*
 * 双端链表结构
 */
typedef struct list {

    // 表头节点
    listNode *head;

    // 表尾节点
    listNode *tail;

    // 节点值复制函数
    void *(*dup)(void *ptr);

    // 节点值释放函数
    void (*free)(void *ptr);

    // 节点值对比函数
    int (*match)(void *ptr, void *key);

    // 链表所包含的节点数量
    unsigned long len;

} list;
```
优点：
1. 双端：获取前置节点和后置节点的时间复杂度都是O(1)
2. 无环：对链表的访问以NULL为终点
3. 带表头指针和表尾指针，复杂度为O(1)
4. 带链表长度计数器，复杂度为O(1)
5. 多态

# 4 字典
又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种保存键值对（key-value pair）的抽象数据结构。

dict.h/dictht 字典:
```cfml
/*
 * 字典
 */
typedef struct dict {

    // 类型特定函数
    dictType *type;

    // 私有数据
    void *privdata;

    // 哈希表
    dictht ht[2];

    // rehash 索引
    // 当 rehash 不在进行时，值为 -1
    int rehashidx; /* rehashing not in progress if rehashidx == -1 */

    // 目前正在运行的安全迭代器的数量
    int iterators; /* number of iterators currently running */

} dict;
```

dict.h/dictht 哈希表:
```cfml
/* This is our hash table structure. Every dictionary has two of this as we
 * implement incremental rehashing, for the old to the new table. */
/*
 * 哈希表
 *
 * 每个字典都使用两个哈希表，从而实现渐进式 rehash 。
 */
typedef struct dictht {
    
    // 哈希表数组
    dictEntry **table;

    // 哈希表大小
    unsigned long size;
    
    // 哈希表大小掩码，用于计算索引值
    // 总是等于 size - 1
    unsigned long sizemask;

    // 该哈希表已有节点的数量
    unsigned long used;

} dictht;
```

dict.h/dictht 哈希表节点:
```cfml
/*
 * 哈希表节点
 */
typedef struct dictEntry {
    
    // 键
    void *key;

    // 值
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;

    // 指向下个哈希表节点，形成链表
    struct dictEntry *next;

} dictEntry;
```
总结：
1. 每个字典有两个哈希表，一个平时使用，另一个进行渐进式rehash时使用
2. Redis使用MurmurHash2算法计算哈希建的哈希值
3. 哈希表使用链地址法解决键冲突，形成单向链表，表头位置插入，复杂度O(1)

# 5 跳跃表（skiplist）


